// Generated by CoffeeScript 1.10.0
(function() {
  var QLite;

  QLite = {
    "private": {
      delay: function(what) {
        setTimeout(what, 0);
      }
    },
    isPromise: function(value) {
      return ((value != null ? value.then : void 0) != null) && typeof value.then === 'function';
    },
    defer: function() {
      var deferred;
      return deferred = {
        "private": {
          chaineds: [],
          settleChained: function(which, how) {
            return function() {
              which.deferred[how.with_operation](how.with_argument);
            };
          },
          settle: function(how) {
            var c1, c2, callback, callback_result, chained, error, error1, j, len, ref;
            ref = this.chaineds;
            for (j = 0, len = ref.length; j < len; j++) {
              chained = ref[j];
              try {
                switch (how.with_operation) {
                  case 'resolve':
                    callback = chained.resolve_callback;
                    break;
                  case 'reject':
                    callback = chained.reject_callback;
                    break;
                  default:
                    null;
                }
                if (callback != null) {
                  callback_result = callback(how.with_argument);
                  if (QLite.isPromise(callback_result)) {
                    c1 = this.settleChained(chained, {
                      with_operation: how.with_operation,
                      with_argument: callback_result
                    });
                    c2 = this.settleChained(chained, {
                      with_operation: 'reject',
                      with_argument: callback_result
                    });
                    callback_result.then(c1, c2);
                  } else {
                    this.settleChained(chained, {
                      with_operation: how.with_operation,
                      with_argument: callback_result
                    })();
                  }
                }
              } catch (error1) {
                error = error1;
                this.settleChained(chained, {
                  with_operation: 'reject',
                  with_argument: error
                })();
              }
            }
          }
        },
        resolve: function(value) {
          var myself;
          myself = this;
          return QLite["private"].delay(function() {
            return myself["private"].settle({
              with_operation: 'resolve',
              with_argument: value
            });
          });
        },
        reject: function(reason) {
          var myself;
          myself = this;
          return QLite["private"].delay(function() {
            return myself["private"].settle({
              with_operation: 'reject',
              with_argument: reason
            });
          });
        },
        promise: {
          then: function(onFulfilled, onRejected) {
            var chained;
            chained = {
              deferred: QLite.defer()
            };
            if (onFulfilled != null) {
              chained.resolve_callback = onFulfilled;
            }
            chained.reject_callback = onRejected != null ? onRejected : function(reason) {
              return reason;
            };
            deferred["private"].chaineds.push(chained);
            return chained.deferred.promise;
          },
          fail: function(onRejected) {
            this.then(null, onRejected);
          },
          "finally": function(onSettled) {
            this.then(onSettled, onSettled);
          }
        }
      };
    },
    all: function(promises) {
      var check, combined, fn, implementation, j, len, notifyFulfillment, notifyRejection, promise;
      combined = QLite.defer();
      implementation = {
        promises: promises,
        values: [],
        fulfilled: []
      };
      check = function() {
        var fulfilled, j, len, n_fulfilled, ref;
        n_fulfilled = 0;
        ref = implementation.fulfilled;
        for (j = 0, len = ref.length; j < len; j++) {
          fulfilled = ref[j];
          if (fulfilled === true) {
            n_fulfilled++;
          }
        }
        if (n_fulfilled === implementation.promises.length) {
          combined.resolve(implementation.values);
        }
      };
      notifyFulfillment = function(promise, value) {
        var i;
        i = implementation.promises.indexOf(promise);
        implementation.fulfilled[i] = true;
        implementation.values[i] = value;
        check();
      };
      notifyRejection = function(reason) {
        combined.reject(reason);
      };
      fn = function(promise) {
        promise.then((function(value) {
          notifyFulfillment(promise, value);
        }), notifyRejection);
      };
      for (j = 0, len = promises.length; j < len; j++) {
        promise = promises[j];
        fn(promise);
      }
      return combined.promise;
    },
    any: function(promises) {
      var check, combined, fn, implementation, j, len, notifyFulfillment, notifyRejection, promise;
      combined = QLite.defer();
      implementation = {
        promises: promises,
        rejected: []
      };
      check = function() {
        var j, len, n_rejected, ref, rejected;
        n_rejected = 0;
        ref = implementation.rejected;
        for (j = 0, len = ref.length; j < len; j++) {
          rejected = ref[j];
          if (rejected === true) {
            n_rejected++;
          }
        }
        if (n_rejected === implementation.promises.length) {
          combined.reject(void 0);
        }
      };
      notifyFulfillment = function(value) {
        combined.resolve(value);
      };
      notifyRejection = function(promise) {
        var i;
        i = implementation.promises.indexOf(promise);
        implementation.rejected[i] = true;
        check();
      };
      fn = function(promise) {
        promise.then(notifyFulfillment, (function() {
          notifyRejection(promise);
        }));
      };
      for (j = 0, len = promises.length; j < len; j++) {
        promise = promises[j];
        fn(promise);
      }
      return combined.promise;
    }
  };

  window.QLite = QLite;

}).call(this);
